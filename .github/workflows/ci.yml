name: Simplified CI/CD Pipeline

on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # Stage 1: Fast Quality Checks (Fail Fast)
  quality-checks:
    name: Code Quality & Fast Checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "fps-genie-rust-cache"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            clang \
            protobuf-compiler \
            libfontconfig1-dev \
            libssl-dev \
            pkg-config

      - name: Check compilation
        run: cargo check --workspace --no-default-features
        continue-on-error: false

      - name: Run rustfmt (non-blocking)
        run: cargo fmt --all -- --check
        continue-on-error: true

      - name: Run clippy (non-blocking) 
        run: cargo clippy --workspace --all-targets --no-default-features -- -D warnings
        continue-on-error: true

      - name: Security audit
        uses: rustsec/audit-check@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Run unit tests
        run: cargo test --workspace --lib --no-default-features
        timeout-minutes: 10

  # Stage 2: Build Container (Build Once, Use Everywhere)
  build-container:
    name: Build Application Container
    runs-on: ubuntu-latest
    needs: quality-checks
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push container
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            RUST_VERSION=1.88

  # Stage 3: Infrastructure Integration Tests (Using docker-compose)
  integration-tests:
    name: Integration Tests with Full Infrastructure
    runs-on: ubuntu-latest
    needs: build-container
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Pull built container
        run: |
          echo "${{ needs.build-container.outputs.image-tag }}" | head -1 | xargs docker pull

      - name: Start infrastructure with docker-compose
        run: |
          docker-compose up -d
          echo "Waiting for services to be ready..."
          sleep 30

      - name: Wait for services health check
        run: |
          # Wait for PostgreSQL
          timeout 60 bash -c 'until docker-compose exec -T postgres pg_isready -U cs2_user; do sleep 2; done'
          
          # Wait for Redis
          timeout 60 bash -c 'until docker-compose exec -T redis redis-cli ping; do sleep 2; done'
          
          # Wait for Qdrant
          timeout 60 bash -c 'until curl -f http://localhost:6333/health; do sleep 2; done'

      - name: Test container functionality with infrastructure
        run: |
          CONTAINER_TAG=$(echo "${{ needs.build-container.outputs.image-tag }}" | head -1)
          
          # Test basic container functionality
          docker run --rm --network="fps-genie_default" $CONTAINER_TAG cs2-data-pipeline --help
          docker run --rm --network="fps-genie_default" $CONTAINER_TAG cs2-demo-analyzer --help
          docker run --rm --network="fps-genie_default" $CONTAINER_TAG cs2-analytics --help

      - name: Run integration tests with infrastructure
        run: |
          # Set environment variables for integration tests
          export DATABASE_URL="postgresql://cs2_user:cs2_password@localhost:5432/cs2_analysis"
          export REDIS_URL="redis://localhost:6379"
          export QDRANT_URL="http://localhost:6333"
          
          # Install minimal rust for integration tests
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
          source ~/.cargo/env
          
          # Install system dependencies for tests
          sudo apt-get update
          sudo apt-get install -y protobuf-compiler libfontconfig1-dev libssl-dev pkg-config
          
          # Run integration tests
          cargo test --workspace --test '*' --features integration-tests --no-default-features
        timeout-minutes: 15

      - name: Clean up infrastructure
        if: always()
        run: docker-compose down -v

  # Stage 4: Kubernetes Deployment Test (minikube)
  k8s-deployment:
    name: Kubernetes Deployment Test
    runs-on: ubuntu-latest
    needs: [build-container, integration-tests]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Start minikube
        uses: medyagh/setup-minikube@latest
        with:
          minikube-version: 'latest'
          driver: docker

      - name: Create K8s manifests
        run: |
          mkdir -p k8s
          
          # Create namespace
          cat <<EOF > k8s/namespace.yaml
          apiVersion: v1
          kind: Namespace
          metadata:
            name: fps-genie
          EOF
          
          # Create deployment
          cat <<EOF > k8s/deployment.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: cs2-data-pipeline
            namespace: fps-genie
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: cs2-data-pipeline
            template:
              metadata:
                labels:
                  app: cs2-data-pipeline
              spec:
                containers:
                - name: cs2-data-pipeline
                  image: ${{ needs.build-container.outputs.image-tag }}
                  command: ["cs2-data-pipeline"]
                  args: ["--help"]
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "100m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
          EOF
          
          # Create service
          cat <<EOF > k8s/service.yaml
          apiVersion: v1
          kind: Service
          metadata:
            name: cs2-data-pipeline-svc
            namespace: fps-genie
          spec:
            selector:
              app: cs2-data-pipeline
            ports:
            - port: 8080
              targetPort: 8080
          EOF

      - name: Deploy to minikube
        run: |
          # Apply manifests
          kubectl apply -f k8s/
          
          # Wait for deployment
          kubectl wait --for=condition=available --timeout=300s deployment/cs2-data-pipeline -n fps-genie
          
          # Check deployment status
          kubectl get pods -n fps-genie
          kubectl describe deployment cs2-data-pipeline -n fps-genie

      - name: Test K8s deployment
        run: |
          # Get pod name
          POD_NAME=$(kubectl get pods -n fps-genie -l app=cs2-data-pipeline -o jsonpath='{.items[0].metadata.name}')
          
          # Check pod logs
          kubectl logs $POD_NAME -n fps-genie
          
          # Test pod health
          kubectl get pod $POD_NAME -n fps-genie -o jsonpath='{.status.phase}'

      - name: Cleanup K8s resources
        if: always()
        run: |
          kubectl delete namespace fps-genie --ignore-not-found=true

  # Stage 5: Performance and Load Tests (Optional - only on main branch)
  performance-tests:
    name: Performance & Load Tests
    runs-on: ubuntu-latest
    needs: [build-container, integration-tests]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pull built container
        run: |
          echo "${{ needs.build-container.outputs.image-tag }}" | head -1 | xargs docker pull

      - name: Start infrastructure
        run: |
          docker-compose up -d
          sleep 30

      - name: Run performance tests
        run: |
          CONTAINER_TAG=$(echo "${{ needs.build-container.outputs.image-tag }}" | head -1)
          
          # Performance test with demo file processing
          echo "Running performance tests..."
          
          # TODO: Add specific performance test commands
          # docker run --rm --network="fps-genie_default" $CONTAINER_TAG cs2-data-pipeline benchmark
          
          echo "Performance tests completed"

      - name: Cleanup
        if: always()
        run: docker-compose down -v